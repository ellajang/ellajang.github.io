{"componentChunkName":"component---src-templates-post-template-tsx","path":"/debugging/delayRendering/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p>거래내역 데이터를 불러오는 과정에서 사용자가 1000개 이상의 결제를 진행할 경우, 거래 내역 데이터의 양이 많아지면서 웹페이지 로딩 속도가 지연될 수 있다고 생각했습니다.<br/>\r\n단순히 useState로 데이터를 관리하는 방식은 무한한 데이터 양을 처리하기에 적합하지 않다고 봤고, 결국 사용자 입장에서 웹 페이지가 느리다는 인상을 줄 수 있다고 생각합니다.<br/>\r\n이러한 문제를 해결하기 위해 어떤 방법이 효과적인지 고민하게 되었습니다.</p>\n</blockquote>\n<h3>1. React-query를 사용한다면?</h3>\n<p>서버에서 데이터를 관리할 때, 많이 사용하는 라이브러리 중 하나가 react-query입니다.<br/>\r\nreact-query는 서버에서 데이터를 받아와 클라이언트 측에서 캐싱 처리하고, 동일한 데이터를 다시 요청하지 않도록 하는 데 매우 유용합니다.<br/>\r\n현재 개발하고 있는 프로젝트에서 redux를 사용해서 상태관리를 하고 있습니다. redux는 주로 클라이언트 측 상태 관리를 담당하기 때문에 react-query를 사용해서 사용할까라는 고민을 했습니다.<br/>\r\n하지만! 이미 redux도 서버에서 받아오는 데이터를 관리하고 있고, react-query도 서버 데이터를 관리하여 역할이 중복되고, 코드를 관리하기에 복잡할 것 같아서 다른 방안을 찾아보았습니다.<br/><br/>\r\n📍 React-query와 Redux를 같이 사용할 때 발생 할 문제</p>\n<ul>\n<li>이미 Redux로 서버 데이터를 관리하고 있는 상황에서 React-query를 추가하면, 서버 데이터를 두 가지 상태 관리 방식으로 처리하게 되어 데이터 흐름이 혼란스러워질 수 있습니다.</li>\n<li>서버 데이터를 React-query로 가져오고 그 데이터를 Redux로 전달하거나, Redux에서 가져온 데이터를 React-query로 처리하는 방식은 동기화 문제나 데이터 불일치가 발생할 수 있습니다.</li>\n<li>만약 동일한 데이터를 Redux와 React-query에서 관리하게 되면, 한 곳에서 데이터가 업데이트되었을 때 다른 쪽에서도 동기화해야 하는 상황이 발생되고 이는 데이터 일관성을 유지하는 것이 어렵습니다.</li>\n<li>Redux로 이미 서버 데이터를 관리하고 있을 경우, 서버 데이터를 다시 React-query로 요청하게 된다면 불필요한 중복 데이터 요청이 발생할 수 있습니다.</li>\n</ul>\n<h3>2. 무한스크롤(Infinite Scroll) 구현</h3>\n<p>대량의 데이터를 한 번에 불러오지 않고 점진적으로 로드하는 방식 중 하나가 무한 스크롤입니다.<br/>\r\n무한 스크롤은 사용자가 페이지를 아래로 스크롤할 때마다 새로운 데이터를 서버로부터 받아와 추가로 로드하는 패턴입니다. 이 방식은 데이터를 한꺼번에 모두 불러오는 대신, 필요한 만큼만 로드하게 하여 로딩 속도를 개선할 수 있다고 생각했습니다.<br/><br/></p>\n<h4>1) Intersection Observer API란?</h4>\n<p>[참고] 📎 (<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\" target=\"_blank\" rel=\"nofollow\">https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API</a></p>\n<p>Intersection Observer는 브라우저에서 요소가 뷰포트 안에 들어오거나 나갈 때 이를 감지할 수 있는 API입니다.\r\n무한 스크롤을 구현할 때 IntersectionObserver를 사용하면 스크롤 이벤트를 직접 처리하지 않고도, 특정 요소가 화면에 나타날 때 자동으로 추가 데이터를 불러오는 트리거로 활용할 수 있습니다.\r\nex)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>\r\n  <span class=\"token parameter\">entries</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entries<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>isIntersecting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token comment\">// 추가 데이터를 불러오는 로직</span>\r\n      <span class=\"token function\">loadMoreData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">threshold</span><span class=\"token operator\">:</span> <span class=\"token number\">1.0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// 관찰할 대상 요소</span>\r\nobserver<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#load-more-trigger'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<br/>\n<h4>2) 전통적인 스크롤 이벤트 방식?</h4>\n<p>스크롤 이벤트를 직접 감지하여 사용자가 페이지 끝에 도달할 때 추가 데이터를 불러오는 방식입니다.\r\n하지만, 이 방식은 스크롤 이벤트가 자주 발생할 수 있어 성능에 부정적인 영향을 줄 수 있습니다.</p>\n<br/>\n<h4>📍Intersection Observer vs 스크롤 이벤트 방식</h4>\n<br/>\n<blockquote>\n<h4>Intersection Observer</h4>\n</blockquote>\n<p><strong>장점</strong></p>\n<ul>\n<li>브라우저에서 기본적으로 관리되므로, 성능 면에서 스크롤 이벤트보다 유리합니다. 매번 스크롤 이벤트를 처리하는 대신, 요소가 뷰포트에 들어오거나 나가는 순간만 감지하여 콜백을 실행하기 때문에 자원 소모가 적습니다.</li>\n<li>스크롤 위치를 직접 계산할 필요 없이, 요소가 뷰포트에 진입할 때 자동으로 콜백이 실행됩니다</li>\n<li>여러 요소를 동시에 감지할 수 있어, 무한 스크롤과 같은 기능에서 여러 데이터가 동시 추가될 때도 효율적으로 처리할 수 있습니다.<br/></li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>복잡한 상황에서 제어가 어렵습니다. 특정 위치에서 정확히 트리거되려면 추가적인 계산이나 설정이 필요합니다.</li>\n<li>최신 브라우저는 지원되지만 구형 브라우저는 지원이 안될 수 있습니다.\r\n<br/><br/></li>\n</ul>\n<blockquote>\n<h4>스크롤 이벤트 방식</h4>\n</blockquote>\n<p><strong>장점</strong></p>\n<ul>\n<li>단순히 페이지의 스크롤 위치를 감지하여 처리하는 방식입니다. 구현 방식이 매우 직관적이며, 간단한 로직으로 빠르게 적용할 수 있습니다.</li>\n<li>사용자가 페이지에서 어느 위치에 있는지 정밀하게 감지할 수 있습니다. 이를 통해 사용자의 스크롤 동작에 따른 세밀한 기능 구현이 가능합니다.<br/></li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>사용자가 페이지를 스크롤할 때마다 매우 빈번하게 발생하므로, 매번 이벤트 핸들러를 실행해야 합니다.</li>\n<li>여러 요소에 대해 스크롤 위치를 각각 감지하는 경우 코드가 난해해질 수 있습니다.</li>\n</ul>\n<h3>3. 무한 스크롤을 사용할 수 없는 상황</h3>\n<p>아쉽게도, 제가 사용하고 있는 API는 데이터를 페이징 없이 한 번에 불러오는 구조였기 때문에 무한 스크롤을 적용해도 근본적인 문제 해결이 어려웠습니다. <br/>\r\n결국 전체 데이터를 불러온 후에 무한 스크롤을 실행하는 것이므로, 데이터 렌더링 지연 문제를 완전히 해결할 수는 없었습니다.\r\n그래서 저는 거래 데이터를 일주일 전까지만 불러오도록 API 요청을 수정하여 불러오는 데이터의 양을 줄이는 방법을 선택했습니다.</p>\n<h3>4. 마무리</h3>\n<p>무한 스크롤은 대량의 데이터를 처리하는 데 효과적인 방법일 수 있지만, 데이터 페이징이 불가능한 API에서는 한계가 있을 수 있습니다. API를 개선할 수 있다면, 꼭 적용해보고 싶은 방법입니다.\r\n특히, 데이터 페이징을 지원하는 API와 Intersection Observer를 결합하면 성능을 더욱 최적화할 수 있습니다.</p>","frontmatter":{"title":"[Next] 데이터 렌더링 지연 문제","summary":"다량의 데이터를 불러오는 과정에서 페이지 로딩 속도가 지연되어 해결 방안에 대해 생각해봤습니다.","date":"2024.04.06.","categories":["All"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAA60lEQVR42p2SO07DQBRFvRca9kFBwxbYDhVrYBFQBs/YE7BSICQLhJQPno/tyURKEBXQoIPsuKBInE9x9TR6elfvnbmRkZ7dqjv5f3Wzor0MRcDIOTat23qUoW4kmuESp95w6hWnXjDSoXtMo74ztVjgVE6dDVjlV/hRSqme0e3GBxmuT7NJQfWQ8T07gxDxYy+os0dsMsHIsJHnVsNCBFw6pRrGfE1P4fOcX3/CfHSLS8doGVosBzBsNjQdvxs+9CXL/Jpy+IRNdNvXx/xyM1yIBfHdgMm9xyWmNzp7xGbN6j2u0LLq3ttj8wd8vHNcWibooAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/54305603eb214d087f016d798d77a64d/becf2/debugging.png","srcSet":"/static/54305603eb214d087f016d798d77a64d/1c872/debugging.png 175w,\n/static/54305603eb214d087f016d798d77a64d/3fd51/debugging.png 350w,\n/static/54305603eb214d087f016d798d77a64d/becf2/debugging.png 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/static/54305603eb214d087f016d798d77a64d/5a1f0/debugging.webp 175w,\n/static/54305603eb214d087f016d798d77a64d/bb551/debugging.webp 350w,\n/static/54305603eb214d087f016d798d77a64d/efd8f/debugging.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":300}},"publicURL":"/static/54305603eb214d087f016d798d77a64d/debugging.png"}}}}]}},"pageContext":{"slug":"/debugging/delayRendering/"}},"staticQueryHashes":[],"slicesMap":{}}