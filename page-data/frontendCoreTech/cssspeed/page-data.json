{"componentChunkName":"component---src-templates-post-template-tsx","path":"/frontendCoreTech/cssspeed/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p>담당하고 있던 웹페이지의 version2를 진행하게되어 CSS를 선택해야하는 상황이 왔습니다. <br/>선택을 하기 위해 조사해보던 중 CSS 방식에 따라 렌더링 성능에도 큰 영향을 줄 수 있다는 것을 알게 되었습니다.\r\n대표적인 CSS 방식인 CSS-in-JS vs CSS Module에 대해 비교해보며 어떤 영향을 주고 있는지 설명하겠습니다.</p>\n</blockquote>\n<h3>1. CSS-in-JS: 컴포넌트 단위 스타일링의 편리함</h3>\n<p> CSS-in-JS는 컴포넌트 안에서 직접 스타일을 정의하는 방식으로, React와 같은 프레임워크에서 특히 많이 사용됩니다. 대표적인 라이브러리로는 styled-components와 Emotion이 있습니다.<br/>\r\n이 방식은 개발자가 CSS와 JavaScript 코드를 한 곳에서 관리할 수 있어, 컴포넌트 단위로 스타일을 격리하고 재사용하기에 매우 편리합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> styled <span class=\"token keyword\">from</span> <span class=\"token string\">'styled-components'</span>\r\n\r\n<span class=\"token keyword\">const</span> Button <span class=\"token operator\">=</span> styled<span class=\"token punctuation\">.</span>button<span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\r\n  background-color: blue;\r\n  color: white;\r\n  padding: 10px;\r\n</span><span class=\"token template-punctuation string\">`</span></span></code></pre></div>\n<p><br/><br/></p>\n<blockquote>\n<h5>장점</h5>\n</blockquote>\n<ul>\n<li>캡슐화된 스타일 : CSS 코드가 컴포넌트 내부에 위치해, 다른 컴포넌트에 영향을 미치지 않음.</li>\n<li>동적 스타일 : JavaScript 변수나 상태에 따라 동적으로 스타일을 변경할 수 있음.\r\n<br/><br/></li>\n</ul>\n<blockquote>\n<h5>단점: 렌더링 성능</h5>\n</blockquote>\n<ul>\n<li>렌더링 속도 : CSS-in-JS는 스타일을 동적으로 생성하기 때문에 렌더링 과정에서 JavaScript가 실행되며, 그로 인해 추가적인 구문 분석과 처리가 필요합니다. 결과적으로 렌더링 속도가 느려질 수 있습니다.</li>\n<li>초기 로딩 시간 증가 : 특히, **서버 사이드 렌더링(SSR)**에서 이 방식은 JavaScript가 동작하지 않는 초기 단계에서 CSS가 빠르게 적용되지 않을 수 있어 초기 로딩이 지연될 수 있습니다.</li>\n</ul>\n<h3>2. CSS Module: 정적인 CSS로 빠른 렌더링</h3>\n<p> CSS Module은 전통적인 CSS 파일을 모듈화하여 사용하지만, 각 컴포넌트마다 고유의 CSS 클래스를 자동으로 생성하여 전역 네임스페이스 충돌을 방지합니다.<br/>\r\n특히 Next.js와 같은 SSR 프레임워크에서 자주 사용됩니다.<br/><br/></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token comment\">// Example.module.css</span>\r\n  <span class=\"token punctuation\">.</span>button <span class=\"token punctuation\">{</span>\r\n    background<span class=\"token operator\">-</span>color<span class=\"token operator\">:</span> blue<span class=\"token punctuation\">;</span>\r\n    <span class=\"token literal-property property\">color</span><span class=\"token operator\">:</span> white<span class=\"token punctuation\">;</span>\r\n    <span class=\"token literal-property property\">padding</span><span class=\"token operator\">:</span> 10px<span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 컴포넌트 파일</span>\r\n<span class=\"token keyword\">import</span> styles <span class=\"token keyword\">from</span> <span class=\"token string\">'./Example.module.css'</span>\r\n\r\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Button</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>button className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>styles<span class=\"token punctuation\">.</span>button<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>Click<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\r\n<br/>\n<blockquote>\n<h5>장점</h5>\n</blockquote>\n<ul>\n<li>빠른 렌더링: CSS가 별도의 파일로 빌드 타임에 처리되므로, 브라우저는 이를 정적 리소스로 바로 로드합니다. 그로 인해 추가적인 구문 분석이 필요 없으며, 빠른 렌더링 속도를 유지할 수 있습니다.</li>\n<li>SSR 친화적: 서버에서 미리 CSS가 렌더링되어 전달되기 때문에 초기 로딩 속도가 빠릅니다.\r\n<br/><br/></li>\n</ul>\n<blockquote>\n<h5>단점: 렌더링 성능</h5>\n</blockquote>\n<ul>\n<li>동적 스타일 한계: CSS-in-JS와 달리 동적으로 JavaScript 상태에 따라 스타일을 변경하는 기능이 부족할 수 있습니다.</li>\n<li>추가적인 파일 관리: CSS 파일을 따로 관리해야 하므로 파일 구조가 복잡해질 수 있습니다.</li>\n</ul>\n<h3>3. 렌더링 성능 비교: CSS-in-JS vs CSS Module</h3>\n<h4>테스트 환경</h4>\n<ul>\n<li>테스트 구성: 간단한 웹 페이지에서 동일한 스타일을 적용한 후, CSS-in-JS와 CSS Module 방식을 각각 사용하여 렌더링 속도를 비교했습니다.</li>\n<li>측정 도구: 크롬 개발자 도구의 Network 탭을 사용해 요청별 렌더링 시간을 측정했습니다. 각 방식이 페이지 로드에 어떤 영향을 미치는지 확인할 수 있습니다.</li>\n</ul>\n<br/>\n<blockquote>\n<h5>a. CSS-in-JS 방식으로 렌더링된 성능 결과입니다.</h5>\n</blockquote>\n<ul>\n<li>\n<p>주요 스크립트 로딩 시간과 fetch 요청들이 보입니다. 특히, 큰 사이즈의 JS 파일(%5Bid%5D.js)이 로딩되는데 787ms가 걸렸으며, fetch 요청에서도 비교적 더 많은 시간이 소요되고 있습니다.<br/>\r\n전체적으로 스크립트 로드 시간과 fetch 요청에서 추가적인 시간 소요가 발생하고 있음을 확인할 수 있습니다.\r\n<br/><br/>\r\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/01894d3e0977e1e069a0ee0fe15a5fd5/22bcb/rendering.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 10.9375%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAcUlEQVR42j3KyQrCMABF0f7/v9WV4srEOrWZE0KaKuKVZpHF4cLjDffphraemDK5VNbt04WUe0t9k3JByAljffvu286FxPcHx9OZQYoLi1KNdR4fYqe0aV2UxvmANhYhrzyeL4x1hJjaPs8LZa2M44E/FmGXA2yCrKwAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/01894d3e0977e1e069a0ee0fe15a5fd5/a59e9/rendering.webp 192w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/0ca9f/rendering.webp 384w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/dc9b9/rendering.webp 768w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/e2c2f/rendering.webp 1152w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/f3efb/rendering.webp 1536w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/8132b/rendering.webp 1733w\" sizes=\"(max-width: 768px) 100vw, 768px\" type=\"image/webp\">\n          <source srcset=\"/static/01894d3e0977e1e069a0ee0fe15a5fd5/3b721/rendering.png 192w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/66595/rendering.png 384w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/fe486/rendering.png 768w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/d2d74/rendering.png 1152w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/e8464/rendering.png 1536w,\n/static/01894d3e0977e1e069a0ee0fe15a5fd5/22bcb/rendering.png 1733w\" sizes=\"(max-width: 768px) 100vw, 768px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/01894d3e0977e1e069a0ee0fe15a5fd5/fe486/rendering.png\" alt=\"rendering\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span></p>\n<p> </p>\n</li>\n</ul>\n<blockquote>\n<h5>b. CSS Module 방식으로 렌더링된 성능 결과입니다.</h5>\n</blockquote>\n<ul>\n<li>동일한 스크립트 파일(%5Bid%5D.js)이지만, 로딩 시간이 48ms로 줄어들었고, 전체적으로 fetch 요청도 짧은 시간 내에 처리되고 있습니다.<br/>\r\n이 방식은 정적 CSS 파일을 사용함으로써 렌더링 시 추가 구문 분석이 필요 없기 때문에, 페이지 로드 성능이 개선되었습니다.\r\n<br/><br/>\r\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/135179253af4ce7e71f01f89a5107f94/a7a60/renderingmodule.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 5.208333333333334%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAP0lEQVR42lWKywqAMAwE/f/PVEKPNg+TRgtbCL14WGYY9mhE6KwY+f33TrBaOYvBI2EeOC/C46N67O/dpajmWDiZTVw8sUYOAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <picture>\n          <source srcset=\"/static/135179253af4ce7e71f01f89a5107f94/a59e9/renderingmodule.webp 192w,\n/static/135179253af4ce7e71f01f89a5107f94/0ca9f/renderingmodule.webp 384w,\n/static/135179253af4ce7e71f01f89a5107f94/dc9b9/renderingmodule.webp 768w,\n/static/135179253af4ce7e71f01f89a5107f94/e2c2f/renderingmodule.webp 1152w,\n/static/135179253af4ce7e71f01f89a5107f94/f3efb/renderingmodule.webp 1536w,\n/static/135179253af4ce7e71f01f89a5107f94/97775/renderingmodule.webp 1900w\" sizes=\"(max-width: 768px) 100vw, 768px\" type=\"image/webp\">\n          <source srcset=\"/static/135179253af4ce7e71f01f89a5107f94/3b721/renderingmodule.png 192w,\n/static/135179253af4ce7e71f01f89a5107f94/66595/renderingmodule.png 384w,\n/static/135179253af4ce7e71f01f89a5107f94/fe486/renderingmodule.png 768w,\n/static/135179253af4ce7e71f01f89a5107f94/d2d74/renderingmodule.png 1152w,\n/static/135179253af4ce7e71f01f89a5107f94/e8464/renderingmodule.png 1536w,\n/static/135179253af4ce7e71f01f89a5107f94/a7a60/renderingmodule.png 1900w\" sizes=\"(max-width: 768px) 100vw, 768px\" type=\"image/png\">\n          <img class=\"gatsby-resp-image-image\" src=\"/static/135179253af4ce7e71f01f89a5107f94/fe486/renderingmodule.png\" alt=\"renderingmodule\" title=\"\" loading=\"lazy\" decoding=\"async\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\">\n        </picture>\n  </a>\n    </span>\r\n<br/><br/></li>\n</ul>\n<table border=\"1\" cellpadding=\"10\" cellspacing=\"0\" style=\"border-collapse: collapse; text-align: center; width: 100%;\">\r\n  <thead>\r\n    <tr>\r\n      <th>방식</th>\r\n      <th>주요 스크립트 로딩 시간</th>\r\n      <th>주요 fetch 요청 시간</th>\r\n      <th>전체 렌더링 시간</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n      <td>CSS-in-JS</td>\r\n      <td>787ms</td>\r\n      <td>2.59s</td>\r\n      <td>약 3.4s</td>\r\n    </tr>\r\n    <tr>\r\n      <td>CSS Module</td>\r\n      <td>48ms</td>\r\n      <td>10ms</td>\r\n      <td>약 0.1s</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\n<p><br/> <br/></p>\n<blockquote>\n<h5>c. 정리</h5>\n</blockquote>\n<p>  이미지에서 확인할 수 있듯이, CSS-in-JS 방식은 JavaScript로 스타일을 동적으로 처리하는 과정에서 추가적인 스크립트 로드와 구문 분석 비용이 발생해 렌더링 속도가 느려집니다.<br/>\r\n반면, CSS Module 방식은 정적 CSS 파일로 관리되어 더 빠른 로딩과 렌더링 속도를 보여주며, fetch 요청 및 스크립트 로딩 시간이 현저히 줄어들었습니다.<br/> <br/></p>\n<p> 따라서, 성능을 중시해야 하는 프로젝트에서는 CSS Module을 사용하여 렌더링 성능을 최적화하는 것이 더 유리한 것으로 보입니다.</p>\n<h3>4. 어떤 CSS 방식이 적합할까?</h3>\n<p> 결국 CSS 방식을 선택할 때는 프로젝트의 규모와 특성에 따라 달라질 수 있습니다.</p>\n<ul>\n<li>소규모 프로젝트: 빠른 개발과 유지보수가 중요한 경우, CSS-in-JS를 사용해 생산성을 높일 수 있습니다.</li>\n<li>대규모 프로젝트: 복잡한 상호작용이 많은 프로젝트에서는 렌더링 성능을 고려해 CSS Module이나 Tailwind CSS와 같은 정적 CSS 방식을 사용하는 것이 더 나은 선택이 될 수 있습니다.</li>\n</ul>\n<h3>5. 결론</h3>\n<p> CSS는 단순한 스타일링 도구를 넘어서, 페이지의 렌더링 성능에도 중요한 영향을 미치는 요소라는 걸 알 수 있습니다.<br/>\r\n특히, CSS-in-JS 방식은 편리한 반면 성능에 영향을 줄 수 있으며, CSS Module은 성능 면에서 더 유리한 선택입니다. 각 프로젝트의 특성과 성능 요구 사항을 고려해 적절한 CSS 방식을 선택하는 것이 중요합니다.</p>\n<p>📎 참고 [ <a href=\"https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/?fbclid=IwAR10q4zhGGIdjdd7l9VyDC9Xn0AU0UkoGeDmTyoWotpt6cxn4T6WHLMPkGg\" target=\"_blank\" rel=\"nofollow\">https://fe-developers.kakaoent.com/2022/220210-css-in-kakaowebtoon/?fbclid=IwAR10q4zhGGIdjdd7l9VyDC9Xn0AU0UkoGeDmTyoWotpt6cxn4T6WHLMPkGg</a> ]</p>","frontmatter":{"title":"CSS-in-JS vs CSS Module: 렌더링 속도에 미치는 영향","summary":"CSS-in-JS와 CSS Module을 비교하면서, 각 방식이 렌더링 속도에 어떤 영향을 미치는지 살펴보겠습니다.","date":"2024.07.20.","categories":["CSS"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABN0lEQVR42tWS0U7CMBRA+f+vEUbHiM4EJCAqEiXBkAg8jOG2bggMYTDWYzYwQCQ++UKTkzQ37entvTenpM5/krskYSkj8QSJp2ccYqdnfnNO6GkoqcG0fEAWUV4RFRgoXwevSOIW2Lr5DOVq+3viWChQvgGRzXblYPVbjAZt7GGbdWijln2cgYk/MJhbJoR1WD7A1z3MaqigSpJlKX6EJZRXgNWQaKO4NivcVurcmHfISUi88uh1qljvTcKpxHEl1VqDl04X3w9IVzzvZY7Utf+yIJEGkWyQzFo7pk+sgyahbTKxasjxG4u5SyBHdF8f6XWf+QxstvGCaOGwcQ2Q4rgpInslcfMnpHVNpCB2dNbjApsPDRWUszKl+8i+IrLTup4dm7+7iF+CrERil4C/j/kXOtj/I/wGzbGuFZdWiJ4AAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/16753e48e7c24da8e3b95dc072a357f2/0c107/cssmodule.png","srcSet":"/static/16753e48e7c24da8e3b95dc072a357f2/f7cdf/cssmodule.png 150w,\n/static/16753e48e7c24da8e3b95dc072a357f2/eebcc/cssmodule.png 300w,\n/static/16753e48e7c24da8e3b95dc072a357f2/0c107/cssmodule.png 600w","sizes":"(min-width: 600px) 600px, 100vw"},"sources":[{"srcSet":"/static/16753e48e7c24da8e3b95dc072a357f2/0e818/cssmodule.webp 150w,\n/static/16753e48e7c24da8e3b95dc072a357f2/a22c2/cssmodule.webp 300w,\n/static/16753e48e7c24da8e3b95dc072a357f2/300eb/cssmodule.webp 600w","type":"image/webp","sizes":"(min-width: 600px) 600px, 100vw"}]},"width":600,"height":400}},"publicURL":"/static/16753e48e7c24da8e3b95dc072a357f2/cssmodule.png"}}}}]}},"pageContext":{"slug":"/frontendCoreTech/cssspeed/"}},"staticQueryHashes":[],"slicesMap":{}}